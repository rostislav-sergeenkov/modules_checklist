<?php

/**
 * @file
 * modules_checklist.module.
 */

// @todo create textarea where user can just copy the array of modules and insert it in settings.php. Use format machine name - human name.
// @todo add link to that file on the status report page. Also display a diff with existing modules there.
// @todo implement same logic for optional modules.
// @todo create Views based sub-module that provides admin log with filters for tracking enabling/disabling modules.
// @todo think how to specify correct version for the sub-module.
// @todo use Entity API and custom schema for log entries.
// @todo implement protection: write into watchdog and variable on disabling the module, extract data from watchdog and variable on enabling.
// @todo print drupal_set_message() on all pages of the site if the list modules doesn't match the config.
// @todo create views display handlers for Module Names and Type (Status).
// @todo update README.txt file
// @todo implement hook_help() for both modules.
// @todo implement log rotation.
// @todo create Project Page and promote the module to the permanent d.org project.
// @todo test log entry when using Drush.
// @todo implement periodic check of systems table to ensure that entry for the manually enabled in DB modules is present in the log.
// @todo install the module on Prod sites.

/**
 * Implements hook_help().
 */
function modules_checklist_help($path, $arg) {

}

/**
 * Returns array of missing required modules and enabled extra modules.
 *
 * Compares enabled modules with the predefined list of modules.
 *
 * @return array
 */
function modules_checklist_get_modules_status() {
  $status = array(
    'optional_modules' => array(),
    'missing_modules' => array(),
    'error_message' => '',
  );

  $required_modules = modules_checklist_get_modules('required');
  $enabled_modules = modules_checklist_get_modules('enabled');
  $config_path = conf_path() . '/settings.php';

  if (empty($required_modules)) {
    $status['error_message'] = t('Please add the list of required modules in !file.',
      array('!file' => $config_path));

    return $status;
  }

  // @todo update logic for optional modules.
  $status['optional_modules'] = array_diff($enabled_modules, $required_modules);
  $status['missing_modules'] = array_diff($required_modules, $enabled_modules);

  return $status;
}

/**
 * Returns array of names of the modules.
 *
 * @param array $modules
 *
 * @return array
 */
function modules_checklist_get_module_names($modules) {
  $module_names = array();
  $modules_data = system_rebuild_module_data();

  foreach ($modules as $module_machine_name) {
    if (isset($modules_data[$module_machine_name]->info['name'])) {
      $module_names[$module_machine_name] = $modules_data[$module_machine_name]->info['name'];
    }
    else {
      $module_names[$module_machine_name] =
        $module_machine_name . ' [' . t('uninstalled and deleted') . ']';
    }
  }

  return $module_names;
}

/**
 * Returns array of human readable names of modules according to their status.
 *
 * @param $status
 * @todo document possible $type
 *
 * @return array|null
 */
function modules_checklist_get_modules($status) {
  switch ($status) {
    case 'enabled':
      $modules = array_keys(module_list());
    case 'required':
      $modules = variable_get('modules_checklist_required_modules', array());
      // @todo implement logic for optional modules.
    case 'optional':
      $modules = variable_get('modules_checklist_optional_modules', array());
    default:
      $modules = array();
  }

  if (!empty($modules)) {
    sort($modules);

    return modules_checklist_get_module_names($modules);
  }

  return $modules;
}
